{
  lib,
  craneLib,
  versionCheckHook,
}: let
  pname = "stash";
  version = (builtins.fromTOML (builtins.readFile ../Cargo.toml)).package.version;
  src = let
    fs = lib.fileset;
    s = ../.;
  in
    fs.toSource {
      root = s;
      fileset = fs.unions [
        (fs.fileFilter (file: builtins.any file.hasExt ["rs"]) (s + /src))
        (s + /Cargo.lock)
        (s + /Cargo.toml)
        (s + /build.rs)
      ];
    };

  cargoArtifacts = craneLib.buildDepsOnly {
    name = "${pname}-deps";
    strictDeps = true;
    inherit src;
  };
in
  craneLib.buildPackage {
    inherit pname src version cargoArtifacts;

    strictDeps = true;

    # Whether cargo's target directory should be copied as an output
    doInstallCargoArtifacts = true;

    # Install Systemd service for Stash into $out/share.
    # This can be used to use Stash in 'systemd.packages'
    postInstall = ''
      mkdir -p $out
      install -Dm755 ${../vendor/stash.service} $out/share/stash.service

      # Since Crane doesn't have a good way of enforcing that our symlinks
      # generated by the build wrapper are correctly linked, we should link
      # them *manually*.
      for bin in stash-copy stash-paste wl-copy wl-paste; do
        ln -sf $out/bin/stash $out/bin/$bin
      done
    '';

    nativeInstallCheckInputs = [versionCheckHook];
    doInstallCheck = true;

    # After the version check, let's see if all binaries are linked correctly.
    # We could probably add a check phase to the versions of each.
    postInstallCheck = ''
      for bin in stash stash-copy stash-paste wl-copy wl-paste; do
        [ -x "$out/bin/$bin" ] || { echo "$bin missing"; exit 1; }
      done
    '';

    meta = {
      description = "Wayland clipboard manager with fast persistent history and multi-media support";
      homepage = "https://github.com/notashelf/stash";
      license = lib.licenses.mpl20;
      maintainers = [lib.maintainers.NotAShelf];
      mainProgram = "stash";
    };
  }
